// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queryUser.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const GetUserOrdersByName = `-- name: GetUserOrdersByName :many
select u.name as "user", o.id as order_id, o.total_amount from shop.orders o 
inner join shop.users u on o.user_id = u.id 
where u.name like $1
`

type GetUserOrdersByNameRow struct {
	User        string         `db:"user" json:"user"`
	OrderID     int            `db:"order_id" json:"order_id"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
}

func (q *Queries) GetUserOrdersByName(ctx context.Context, name string) ([]*GetUserOrdersByNameRow, error) {
	rows, err := q.db.Query(ctx, GetUserOrdersByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUserOrdersByNameRow{}
	for rows.Next() {
		var i GetUserOrdersByNameRow
		if err := rows.Scan(&i.User, &i.OrderID, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UserAdd = `-- name: UserAdd :one
insert into shop.Users(name, email, "password") 
values ($1, $2, $3) returning id
`

type UserAddParams struct {
	Name     string  `db:"name" json:"name"`
	Email    *string `db:"email" json:"email"`
	Password string  `db:"password" json:"password"`
}

func (q *Queries) UserAdd(ctx context.Context, arg UserAddParams) (int, error) {
	row := q.db.QueryRow(ctx, UserAdd, arg.Name, arg.Email, arg.Password)
	var id int
	err := row.Scan(&id)
	return id, err
}

const UserByID = `-- name: UserByID :one
select id, name, email, password from shop.Users u
where u.id = $1
`

func (q *Queries) UserByID(ctx context.Context, id int) (*ShopUser, error) {
	row := q.db.QueryRow(ctx, UserByID, id)
	var i ShopUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const UserDelete = `-- name: UserDelete :exec
DELETE from shop.Users
where name=$1
`

func (q *Queries) UserDelete(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, UserDelete, name)
	return err
}

const UserGetByName = `-- name: UserGetByName :one
select id, name, email, password from shop.users u 
where name = $1
`

func (q *Queries) UserGetByName(ctx context.Context, name string) (*ShopUser, error) {
	row := q.db.QueryRow(ctx, UserGetByName, name)
	var i ShopUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const UserUpdate = `-- name: UserUpdate :exec
update shop.users 
set name = $2
where "name" = $1
`

type UserUpdateParams struct {
	Name   string `db:"name" json:"name"`
	Name_2 string `db:"name_2" json:"name_2"`
}

func (q *Queries) UserUpdate(ctx context.Context, arg UserUpdateParams) error {
	_, err := q.db.Exec(ctx, UserUpdate, arg.Name, arg.Name_2)
	return err
}

const Users = `-- name: Users :many
select id, name, email, password from shop.users u
`

func (q *Queries) Users(ctx context.Context) ([]*ShopUser, error) {
	rows, err := q.db.Query(ctx, Users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ShopUser{}
	for rows.Next() {
		var i ShopUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UsersStatistic = `-- name: UsersStatistic :many
select u.name as "user", sum(o.total_amount) as total_orders, avg(p.price) as "avr price" 
from shop.orders o  
inner join shop.orderproducts op on o.id = op.order_id 
inner join shop.products p on op.product_id = p.id 
right join shop.Users u on o.user_id = u.id 
group by u.name
`

type UsersStatisticRow struct {
	User        string  `db:"user" json:"user"`
	TotalOrders int64   `db:"total_orders" json:"total_orders"`
	AvrPrice    float64 `db:"avr price" json:"avr price"`
}

func (q *Queries) UsersStatistic(ctx context.Context) ([]*UsersStatisticRow, error) {
	rows, err := q.db.Query(ctx, UsersStatistic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UsersStatisticRow{}
	for rows.Next() {
		var i UsersStatisticRow
		if err := rows.Scan(&i.User, &i.TotalOrders, &i.AvrPrice); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
